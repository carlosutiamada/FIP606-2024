{
  "hash": "f87aa58ab90248f788817b31a4323a60",
  "result": {
    "markdown": "---\ntitle: \"Análise exploratória 2\"\nformat: html\nmessage: false\nwarning: false\n---\n\n\n# Conjunto de dados 3\n\nNo site [R4PDE.net](https://r4pde.net/temporal-fitting.html#entering-data) foi importado os dados denominados de `pepper`.\n\nEsse conjunto de dados fornece informações sobre a incidência de 3 epidemias diferentes na pimenta em função do tempo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\npepper <- \n  tribble(\n   ~t,  ~`1`,  ~`2`,  ~`3`,\n   0,  0.08, 0.001, 0.001,\n   7,  0.13,  0.01, 0.001,\n  14,  0.78,  0.09,  0.01,\n  21,  0.92,  0.25,  0.05,\n  28,  0.99,   0.8,  0.18,\n  35, 0.995,  0.98,  0.34,\n  42, 0.999,  0.99,  0.48,\n  49, 0.999, 0.999,  0.74\n  ) \npepper\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 4\n      t   `1`   `2`   `3`\n  <dbl> <dbl> <dbl> <dbl>\n1     0 0.08  0.001 0.001\n2     7 0.13  0.01  0.001\n3    14 0.78  0.09  0.01 \n4    21 0.92  0.25  0.05 \n5    28 0.99  0.8   0.18 \n6    35 0.995 0.98  0.34 \n7    42 0.999 0.99  0.48 \n8    49 0.999 0.999 0.74 \n```\n:::\n:::\n\n\nVisualizando o conjunto de dados, pode-se perceber que eles estão no formato largo. Para que seja possível realizar uma análise exploratória desses dados, é necessário usar a função `pivot_longer()`do `tidyverse` para tranformar a tabela no formato longo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\npepper |> \n  pivot_longer(2:4,\n               names_to = \"epidemic\",\n               values_to = \"inc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 24 × 3\n       t epidemic   inc\n   <dbl> <chr>    <dbl>\n 1     0 1        0.08 \n 2     0 2        0.001\n 3     0 3        0.001\n 4     7 1        0.13 \n 5     7 2        0.01 \n 6     7 3        0.001\n 7    14 1        0.78 \n 8    14 2        0.09 \n 9    14 3        0.01 \n10    21 1        0.92 \n# ℹ 14 more rows\n```\n:::\n:::\n\n\n::: callout-note\nPara montagem dos gráficos, a tabela de dados deve estar no formato longo.\n:::\n\n## Trabalhando com gráfico de linha\n\nPor ser um conjunto de dados com uma resposta numérica contínua em um fator temporal, esses dados foram transformados em um gráfico de linhas usando o `geom_point()`e o `geom_line()`.\n\nPara atribuir um nome para cada linha formada, foi usada a função `annotate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npepper |> \n  pivot_longer(2:4,\n               names_to = \"epidemic\",\n               values_to = \"inc\") |> \n  ggplot(aes(t, inc, color = epidemic))+\n  geom_point()+\n  geom_line()+\n  annotate(geom = \"text\",\n           x = 10,\n           y = 0.75,\n           label = \"1\")+\n  annotate(geom = \"text\",\n           x = 25,\n           y = 0.75,\n           label = \"2\")+\n  annotate(geom = \"text\",\n           x = 47,\n           y = 0.75,\n           label = \"3\")+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n# Conjunto de dados 4\n\nUsando os mesmos dados do conjunto de dados 2, foi criado uma tabela de contingência sobre o número de fazendas com incidência de ferrugem do café por região e por zona. Para isso, a função `count()` é usada para contar quantas ocorrências têm de determinadas variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- read_csv(\"https://raw.githubusercontent.com/emdelponte/paper-coffee-rust-Ethiopia/master/data/survey_clean.csv\")\n\ncr |> \n  count(region, zone)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  region zone             n\n  <chr>  <chr>        <int>\n1 Oromia Bale            30\n2 Oromia Ilu AbaBora     45\n3 Oromia Jimma           45\n4 Oromia West Wellega    45\n5 SNNPR  Bench Maji      45\n6 SNNPR  Gedio           45\n7 SNNPR  Keffa           45\n8 SNNPR  Sheka           45\n9 SNNPR  Sidama          60\n```\n:::\n:::\n\n\nA função `count()` fornece uma tabela de formato longo. Caso seja necessário uma tabela de contingência de formato largo, pode ser usado a função `tabyl()` do pacote `janitor`.\n\nUsando a função `tabyl()` foi criado a tabela de contingência em relação a região por zona; zona por região; e cultivar por região\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\ncr |> \n  tabyl(region, zone) #Formato largo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n region Bale Bench Maji Gedio Ilu AbaBora Jimma Keffa Sheka Sidama West Wellega\n Oromia   30          0     0          45    45     0     0      0           45\n  SNNPR    0         45    45           0     0    45    45     60            0\n```\n:::\n\n```{.r .cell-code}\ncr |> \n  tabyl(zone, region)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         zone Oromia SNNPR\n         Bale     30     0\n   Bench Maji      0    45\n        Gedio      0    45\n  Ilu AbaBora     45     0\n        Jimma     45     0\n        Keffa      0    45\n        Sheka      0    45\n       Sidama      0    60\n West Wellega     45     0\n```\n:::\n\n```{.r .cell-code}\ncr |> \n  tabyl(cultivar, region)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n cultivar Oromia SNNPR\n Improved     23    60\n    Local     50    66\n  Mixture     92   114\n```\n:::\n:::\n\n\nFoi realizado também a contagem das formas de manejo das fazendas em função das cultivares.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr |> \n  count(farm_management, cultivar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n  farm_management cultivar     n\n  <chr>           <chr>    <int>\n1 Intensive       Improved    83\n2 Intensive       Mixture     82\n3 Minimal         Local       10\n4 Minimal         Mixture     59\n5 Moderate        Local        4\n6 Moderate        Mixture     65\n7 Unmanaged       Local      102\n```\n:::\n:::\n\n\n## Trabalhando com gráfico de colunas\n\nSobre a contagem das formas de manejo das fazendas em função das cultivares, foi criado um gráfico de colunas usando a função `geom_col()`. O gráfico de colunas é bastante usado para representar valores numéricos associados a categorias.\n\nJunto ao gráfico, foi usado a função `facet_wrap()` para dividir os gráficos em função das cultivares.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggthemes)\n\ncr |> \n  count(farm_management, cultivar) |> \n  ggplot(aes(cultivar, n, fill = farm_management, label = n))+\n  geom_col(position = \"dodge2\")+\n  scale_fill_canva()+\n  theme_bw()+\n  theme(strip.text.x = element_blank(),\n        legend.position = \"top\")+\n  geom_text(position = position_dodge(width = 0.9))+\n  facet_wrap(~cultivar, scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n# Conjunto de dados 5\n\nDessa vez foi utilizado os mesmos dados do conjunto de dados 1, sobre o comprimento de plantas em função da aplicação e não aplicação de Mg2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gsheet)\nmg <- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=983033137\")\nmg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 3\n   trat      rep  comp\n   <chr>   <dbl> <dbl>\n 1 Mg2         1   9  \n 2 Mg2         2  12.5\n 3 Mg2         3  10  \n 4 Mg2         4   8  \n 5 Mg2         5  13.2\n 6 Mg2         6  11  \n 7 Mg2         7  10.8\n 8 Mg2         8   9.5\n 9 Mg2         9  10.8\n10 Mg2        10  10.4\n11 control     1  13.7\n12 control     2  15.9\n13 control     3  15.7\n14 control     4  14.2\n15 control     5  15.9\n16 control     6  16.5\n17 control     7  18  \n18 control     8  14.4\n19 control     9  16.4\n20 control    10  16  \n```\n:::\n:::\n\n\n## Trabalhando com gráfico errorbar\n\nComo o conjunto de dados envolve um número grande de repetições, torna-se interessante realizar um gráfico de errorbar para demonstrar a faixa de variabilidade entre os valores.\n\nPara usar o `geom_errobar()`, é preciso primeiramente encontrar a média e o desvio padrão dos dados. Para isso pode ser utilizado a função`group_by()`para especificar o`trat`e a função`summarize()`para encontrar a média e desvio padrão. Tendo essas informações, pode-se criar um gráfico de barras com o error bar, usando o`geom_col()`e o`geom_errobar()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmg |> \n  group_by(trat) |> \n  summarise(mean_comp = mean(comp),\n            sd_comp = sd(comp)) |> \n  ggplot(aes(trat, mean_comp))+\n  geom_col(fill = \"steelblue\", width = 0.5)+\n  geom_point(size = 3)+\n  ylim(0, 20)+\n  geom_errorbar(aes(ymin = mean_comp - sd_comp,\n                    ymax = mean_comp + sd_comp),\n                width = 0.1)+\n  annotate(geom = \"text\",  #Pode ser usado para mostrar que é estatisticamente diferente\n           x = 1,\n           y = 17.5,\n           label = \"*\")\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n# Conjunto de dados 6\n\nEsse conjunto de dados contem as notas das provas (sabatinas) aplicadas em aula durante a disciplina FIP 606. Os dados foram importados do Google Sheet usando o pacote `gsheet`e a função `gsheet2tbl()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas <- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit#gid=1092065531\")\n```\n:::\n\n\n## Criando subconjuntos e tabela de contingência\n\nPara observar a quantidade e a frequência de nota de cada prova, foi separado os dados da prova 1 com os dados da prova 2, usando a função `select()` selecionando apenas as colunas `prova` e `nota`, e a função `filter()` separando a prova 1 da prova 2. Desse modo foi criado 2 subconjuntos de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas1 <- notas |> \n  select(prova, nota) |> \n  filter(prova == \"1\")\nnotas1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 2\n   prova  nota\n   <dbl> <dbl>\n 1     1  71.4\n 2     1  92.9\n 3     1  85.7\n 4     1  42.9\n 5     1 100  \n 6     1  85.7\n 7     1 100  \n 8     1  57.1\n 9     1 100  \n10     1  71.4\n# ℹ 12 more rows\n```\n:::\n\n```{.r .cell-code}\nnotas2 <- notas |> \n  select(prova, nota) |> \n  filter(prova == \"2\")\nnotas2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 2\n   prova  nota\n   <dbl> <dbl>\n 1     2  81.2\n 2     2  68.8\n 3     2  87.5\n 4     2  87.5\n 5     2  87.5\n 6     2 100  \n 7     2 100  \n 8     2 100  \n 9     2 100  \n10     2  43.8\n# ℹ 12 more rows\n```\n:::\n:::\n\n\nApós isso, foi usado a função `count()` dentro de cada subconjunto para contar a frequência de cada nota.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas1 |> \n  count(nota)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n   nota     n\n  <dbl> <int>\n1  42.9     2\n2  57.1     2\n3  64.3     2\n4  71.4     4\n5  85.7     3\n6  92.9     3\n7 100       6\n```\n:::\n\n```{.r .cell-code}\nnotas2 |> \n  count(nota)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n   nota     n\n  <dbl> <int>\n1  43.8     3\n2  56.2     1\n3  68.8     5\n4  81.2     2\n5  87.5     4\n6 100       7\n```\n:::\n:::\n\n\n## Sumário e Histograma\n\nPara observar os dados sumarizados foi usado a função `group_by()` para agrupar os dados gerais em 2 grupos (prova 1 e prova 2), e depois foi usado a função `summarise()` para encontrar média, desvio padrão e mediana por prova, usando os argumentos `mean()`, `sd()` e `median()`, respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas |> \n  group_by(prova) |> \n  summarise(nota_mean = mean(nota),\n            nota_sd = sd(nota),\n            nota_med = median(nota))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  prova nota_mean nota_sd nota_med\n  <dbl>     <dbl>   <dbl>    <dbl>\n1     1      79.5    19.0     85.7\n2     2      79.3    19.7     84.4\n```\n:::\n:::\n\n\nPara a análise exploratória, foi realizado um histograma para cada prova, usando a função `geom_histogram()` para os subconjuntos criados. O histograma foi utilizado para demonstrar a distribuição de frequências. Após formados, os histogramas foram juntados em uma mesma imagem usando o pacote `patchwork()`. No histograma, para delimitar o número de colunas que aparecem no gráfico, foi usado o argumento `bins = 5`, e foi criado uma linha que marca a média dos dados usando a função `geom_vline()`. Para que os dois gráficos ficassem com o eixo Y padronizado, foi colocado `ylim(0,10)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia1 <- mean(notas1$nota)\nmedia2 <- mean(notas2$nota)\n\nlibrary(ggthemes)\np1 <- notas1 |> \n  ggplot(aes(x = nota))+\n  geom_histogram(bins = 5, fill = \"dark blue\", color = \"white\")+\n  geom_vline(xintercept = media1, color =\"red\", linetype = \"dashed\") +\n  scale_fill_canva()+\n  theme_bw(base_size = 14)+\n  theme(legend.position = \"bottom\")+\n  annotate(geom = \"text\",\n           x = 72,\n           y = 7.5,\n           label = \"Mean\")+\n  ylim(0,10)+\n  labs(y = \"Frequency\",\n       x = \"Notas\",\n       title = \"Prova 1\")\n\np2 <- notas2 |> \n  ggplot(aes(x = nota))+\n  geom_histogram(bins = 5, fill = \"orange\", color = \"white\")+\n  geom_vline(xintercept = media2, color =\"red\", linetype = \"dashed\") +\n  scale_fill_canva()+\n  theme_bw(base_size = 14)+\n  theme(legend.position = \"bottom\")+\n  annotate(geom = \"text\",\n           x = 72,\n           y = 6.5,\n           label = \"Mean\")+\n  ylim(0,10)+\n  labs(y = \"Frequency\",\n       x = \"Notas\",\n       title = \"Prova 2\")\n\nlibrary(patchwork)\n(p1 + p2) + \n  plot_layout(guides = \"collect\",\n              axes = \"collect\")\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nAtravés da sumarização, pode-se observar que os valores médios das notas das duas provas são bem próximos, sendo 79.54 na prova 1 e 79.26 na prova 2. Pelo histograma também pode-se observar que na prova 1 a frequência de notas superiores a 90 foi maior do que o observado na prova 2, enquanto que na prova 2 a frequência de notas inferiores a 50 foi maior do que na prova 1.\n\n## Trabalhando com Boxplot\n\nUma outra análise exploratória que pode ser realizado é o boxplot, usando a função `geom_boxplot()`. Para que o gráfico considere as duas provas como diferentes, foi usado o `factor()` para que cada prova seja considerada como fator. Também foram adicionados os pontos usando `geom_jitter()`, que representa as notas tiradas em cada prova.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas |> \n  ggplot(aes(factor(prova), nota))+\n  geom_boxplot(fill = \"light blue\")+\n  geom_jitter(width = 0.05)+\n  labs(x = \"Notas\",\n       y = \"Prova\")\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nNo boxplot pode-se observar que embora a prova 1 apresente a mediana um pouco maior que a prova 2, 50% das notas na prova 2 se encontram concentrados acima da nota 70, enquanto que 50% das notas na prova 1 se concentram abaixo da nota 100, mais ou menos entre 65 e 98.\n\n## Trabalhando com gráfico de errobar\n\nPor último, também foi construído um gráfico de errobar usando as funções `geom_point()` e `geom_errobar()`. No qual o ponto médio representa a média de notas em cada prova e o errobar corresponde ao intervalo de confiança. Também foi definido um limite para o eixo Y usando o `ylim(0,100)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas |> \n  group_by(prova) |> \n  summarise(nota_mean = mean(nota),\n            nota_sd = sd(nota))|> \n  ggplot(aes(factor(prova), nota_mean, color = prova))+\n  theme_few()+\n  theme(legend.position = \"none\")+\n  geom_point(size = 3)+  \n  geom_errorbar(aes(ymin = nota_mean - nota_sd,\n                    ymax = nota_mean + nota_sd),\n                width = 0.1)+\n  ylim(0,100)\n```\n\n::: {.cell-output-display}\n![](Aula5_quarto_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nComo foi visto anteriormente na sumarização, os valores da média e desvio padrão foram bem semelhantes entre as duas provas, portanto não foi possível observar muita diferença através do gráfico de errobar.\n",
    "supporting": [
      "Aula5_quarto_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}